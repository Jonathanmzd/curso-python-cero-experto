# Indice

## Curso de Introducci√≥n al Pensamiento Computacional con Python

### Introducci√≥n al pensamiento computacional

Objetivos

* Aprender a resolver problemas de manera computacional
* Entender los puntos en com√∫n entre todos los lenguajes de programaci√≥n
* Desarrollar las bases para una carrera en Computer Science

### Introducci√≥n al c√≥mputo

**Resumen Introducci√≥n al C√≥mputo**

* **"Primera computadora"** creada por los griegos, calcula la posici√≥n del sol, luna y algunas constelaciones.

* En 1801, Telar de Jacquar, separa el resultado de la informacion que contiene las instrucciones.

* Siglo XIX, Motor anal√≠tico de Babbage, haciendo uso del avances en mec√°nica (engranajes) de su √©poca logra separar instrucciones de calculo y realizar varios c√°lculos a la vez.

* Finales siglo XIX, ENIAC (Eectronic Numerical Integrator and Computer) usaba sistema decimal. creada por Alan Turing y Alonso. Esta √©poca exig√≠a exactitud en los c√°lculos que hac√≠an que compa√±√≠as dependieran de esta(Compa√±√≠as Ferroviarias por ejemplo). Turing y Alonso, Descubrieron que matem√°ticamente todos los algoritmos pod√≠amos reducirlos a una secuencia de soluciones matem√°ticas.

* En 1945, Arquitectura de Von Neumann, EDVAC (Electronic Discrete Variable Automatic Computer) usaba sistema binario. Su aporte fue el descubrimiento que dentro de los componentes electr√≥nicos se puede usar una serie de hadward para realizar el computo y almacenar datos dentro de memoria.

* En 1950, Microchip, ejemplo Apple 1

* En siglo XX, Arquitectura de Feymann, aporta las bases matem√°ticas de computo cu√°ntico.

![alt text](image.png)

C√≥mputo y computadoras

* Las computadoras hacen dos cosas: hacen c√°lculos y recuerdan el resultado de dichos c√°lculos.
* Por la mayor√≠a de la historia humana, est√°bamos limitados por la velocidad del cerebro y la mano.
* A√∫n con las computadoras modernas existen problemas que no podemos resolver.

### Introducci√≥n a los lenguajes de programaci√≥n

¬øQu√© es un lenguaje de programaci√≥n? Es un lenguaje formal que, mediante una serie de instrucciones, le permite a un programador escribir un conjunto de √≥rdenes, acciones consecutivas, datos y algoritmos para, de esa forma, crear programas que controlen el comportamiento f√≠sico y l√≥gico de una m√°quina.

¬øQu√© tipos de lenguaje de programaci√≥n existen? El lenguaje de programaci√≥n es la base para construir todas las aplicaciones digitales que se utilizan en el d√≠a a d√≠a y se clasifican en dos tipos principales: lenguaje de bajo nivel y de alto nivel.

Lenguaje de programaci√≥n de bajo nivel Son lenguajes totalmente orientados a la m√°quina.

Este lenguaje sirve de interfaz y crea un v√≠nculo inseparable entre el hardware y el software.

Adem√°s, ejerce un control directo sobre el equipo y su estructura f√≠sica. Para aplicarlo adecuadamente es necesario que el programador conozca s√≥lidamente el hardware. √âste se subdivide en dos tipos:

Lenguaje m√°quina Es el m√°s primitivo de los lenguajes y es una colecci√≥n de d√≠gitos binarios o bits (0 y 1) que la computadora lee e interpreta y son los √∫nicos idiomas que las computadoras entienden.

Ejemplo: 10110000 01100001

No entendemos muy bien lo que dice ¬øverdad? Por eso, el lenguaje ensamblador nos permite entender mejor a qu√© se refiere √©ste c√≥digo.

Lenguaje ensamblador El lenguaje ensamblador es el primer intento de sustituci√≥n del lenguaje de m√°quina por uno m√°s cercano al utilizado por los humanos.

Un programa escrito en √©ste lenguaje es almacenado como texto (tal como programas de alto nivel) y consiste en una serie de instrucciones que corresponden al flujo de √≥rdenes ejecutables por un microprocesador.

Sin embargo, dichas m√°quinas no comprenden el lenguaje emsamblador, por lo que se debe convertir a lenguaje m√°quina mediante un programa llamado Ensamblador.

Este genera c√≥digos compactos, r√°pidos y eficientes creados por el programador que tiene el control total de la m√°quina.

Ejemplo: MOV AL, 61h (asigna el valor hexadecimal 61 al registro ‚ÄúAL‚Äù)

Lenguaje de programaci√≥n de alto nivel Tienen como objetivo facilitar el trabajo del programador, ya que utilizan unas instrucciones m√°s f√°ciles de entender.

Adem√°s, el lenguaje de alto nivel permite escribir c√≥digos mediante idiomas que conocemos (espa√±ol, ingl√©s, etc.) y luego, para ser ejecutados, se traduce al lenguaje de m√°quina mediante traductores o compiladores.

++Traductor++ Traducen programas escritos en un lenguaje de programaci√≥n al lenguaje m√°quina de la computadora y a medida que va siendo traducida, se ejecuta.

++Compilador++ Permite traducir todo un programa de una sola vez, haciendo una ejecuci√≥n m√°s r√°pida y puede almacenarse para usarse luego sin volver a hacer la traducci√≥n.

**Programaci√≥n**

* Turing completeness

* Los lenguajes de programaci√≥n modernos dan primitivos que son m√°s convenientes que los primitivos de Turing.

**Lenguajes**

**Sintaxis** Define la secuencia de s√≠mbolos que est√° bienformada.

**Sem√°ntica est√°tica** Define qu√© enunciados con sintaxis correcta tienen significado

**Sem√°ntica** Define el significado. En los lenguajes de programaci√≥n s√≥lo hay un significado.

### Preparaci√≥n de tu computadora

Antes de comenzar este curso aseg√∫rate de preparar tu entorno de trabajo para poder hacer todos los ejercicios. A continuaci√≥n te compartir√© los pasos que debes seguir para configurar tu computadora.

Si est√°s usando Windows aseg√∫rate de instalar lo siguiente en tu computadora:

Python 3.7 (o superior)

1. Para obtener el instalador dir√≠gete a <https://www.python.org/downloads/>

![alt text](image-1.png)

2. Descarga el instalador y ejec√∫talo en tu computadora.

![alt text](image-2.png)

3. Habilita la casilla de verificaci√≥n en Install launcher for all users y Add Python 3.8 to PATH. A continuaci√≥n presiona en Install Now. Windows te solicitar√° permisos para instalar Python en tu computadora.

![alt text](image-3.png)

4. Al finalizar la instalaci√≥n se abrir√° una ventana como la siguiente, en ella deber√°s presionar en la opci√≥n Disable path length limit. Windows te solicitar√° permisos para realizar este cambio.

![alt text](image-4.png)

Visual Studio Code
En el curso el profesor utiliza Visual Studio Code, un editor de textos que tiene integradas varias herramientas que te ayudar√°n a desarrollar tus ejercicios con facilidad. Para obtenerlo en tu computadora, dir√≠gete a: <https://code.visualstudio.com/>

![alt text](image-5.png)

1. Realiza una instalaci√≥n normal de Visual Studio code.

![alt text](image-6.png)

Una vez instalado se ejecutar√° Visual Studio Code.

2. En Visual Studio Code dir√≠gete al panel de Extensiones, se encuentra en el panel lateral izquierdo. Ah√≠ deber√°s buscar la extensi√≥n llamada Python.

![alt text](image-7.png)

3. Selecciona la extensi√≥n creada por Microsoft, la identificar√°s por ser similar a la que se muestra en la im√°gen. Una vez seleccionada, inst√°lala

![alt text](image-8.png)

4. Una vez instalada, reinicia Visual Studio Code.
Listo con esto podr√°s correr los programas que escribas en python en la terminal de Visual Studio Code.

Cuando quieras correr tu programa en la terminal de Visual Studio Code, puedes introducir la direcci√≥n como lo muestra el profesor en el curso o presionar en el bot√≥n ‚ÄúRun Python File in Terminal‚Äù

![alt text](image-9.png)

Para este caso en particular tengo instalado WSL Ubuntu

### Elementos b√°sicos de Python

Lenguajes de programaci√≥n

* Bajo nivel vs. alto nivel

* General vs. dominio espec√≠fico

* Interpretado vs. compilado

**¬øQu√© es un lenguaje de programaci√≥n?** Es un lenguaje formal que, mediante una serie de instrucciones, le permite a un programador escribir un conjunto de √≥rdenes, acciones consecutivas, datos y algoritmos para, de esa forma, crear programas que controlen el comportamiento f√≠sico y l√≥gico de una m√°quina.

**¬øQu√© tipos de lenguaje de programaci√≥n existen?** El lenguaje de programaci√≥n es la base para construir todas las aplicaciones digitales que se utilizan en el d√≠a a d√≠a y se clasifican en dos tipos principales: lenguaje de bajo nivel y de alto nivel.

Lenguaje de programaci√≥n de bajo nivel Son lenguajes totalmente orientados a la m√°quina. Este lenguaje sirve de interfaz y crea un v√≠nculo inseparable entre el hardware y el software.

Lenguaje de programaci√≥n de alto nivel Tienen como objetivo facilitar el trabajo del programador, ya que utilizan unas instrucciones m√°s f√°ciles de entender.

Lenguaje espec√≠fico de dominio En desarrollo de software e ingenier√≠a de dominio, un lenguaje espec√≠fico de dominio, o "lenguaje espec√≠fico del dominio", (en ingl√©s domain-specific language, DSL) es un lenguaje de programaci√≥n o especificaci√≥n dedicado a resolver un problema en particular, representar un problema espec√≠fico y proveer una t√©cnica para solucionar una situaci√≥n particular. El concepto no es nuevo pero se ha vuelto m√°s popular debido al aumento del uso de modelaje espec√≠fico del dominio.1‚Äã

Lenguaje de prop√≥sito general Se llama lenguaje de prop√≥sito general al lenguaje de programaci√≥n cuyos procedimientos, instrucciones y estructuras de datos est√°n dise√±ados para resolver todo tipo de problemas.

Lenguaje de interpretados y compilados La principal diferencia entre un lenguaje compilado y uno interpretado es que el lenguaje compilado requiere un paso adicional antes de ser ejecutado, la compilaci√≥n, que convierte el c√≥digo que escribes a lenguaje de m√°quina. Un lenguaje interpretado, por otro lado, es convertido a lenguaje de m√°quina a medida que es ejecutado.

Ejemplos de lenguajes compilados incluyen C, C++, Java, Go y Rust, entre muchos otros. Ejemplos de lenguajes interpretados incluyen Ruby, Python y JavaScript, entre muchos otros. A todos estos lenguajes se les conoce como lenguajes de alto nivel.

```py
1 + 1 # 1
'Platzi' / 5 # Error
'Platzi' * 3 #PlatziPlatziPlatzi
#PrintStatement
print('Hola mundo')
'Mr' + '. Internatuta'
2 + 2
```

**¬øQue es un objeto?** Concepto, abstracci√≥n o cosa con l√≠mites bien definidos y con significado para el problema que se est√° manejando

* Escalares vs No escalares -Tipos int. float. bool. str.

```py
#Definiendo variables
my_int  = 1
my_float = 1.0
my_bool = True
my_none = None
my_str = 'Hola'
```

```py
#Imprimiendo el tipo
type(my_int)
type(my_float)
type(my_bool)
type(my_none)
type(my_str)
```

**¬øQue pasa si ejecutas esto?**

```py
1 + 1 
2 - 5
2.0 * 3
6 // 2
6 // 4
6 / 4
7 % 2
2 ** 2
```

Resultado

```py
>>> 1 + 1
2
>>> 2 - 5
-3
>>> 2.0 * 3
6.0
>>> 6 // 2
3
>>> 6 // 4
1
>>> 6 / 4
1.5
>>> 7 % 2
1
>>> 2 ** 2
```

![alt text](image-10.png)

![alt text](image-11.png)

![alt text](image-12.png)

### Asignaci√≥n de variables

![alt text](image-13.png)

Corregir definicion de variables

![alt text](image-14.png)

Reasignacion de memoria

![alt text](image-15.png)

![alt text](image-16.png)

**Un recolector de basura (del ingl√©s garbage collector)** es un mecanismo impl√≠cito de gesti√≥n de memoria implementado en algunos lenguajes de programaci√≥n de tipo interpretado o semiinterpretado.

**Variables**

* Pueden contener may√∫sculas, min√∫sculas, n√∫meros (sin comenzar con uno) y el s√≠mbolo _
* No pueden llamarse como las palabras reservadas

![alt text](image-17.png)

* Hacen los programas m√°s comprensibles.
* Son simplemente nombres que apuntan a un valor en memoria.
* El operador de asignaci√≥n (=) asocia una variable con un valor.

### Cadenas y entradas

![alt text](image-18.png)

![alt text](image-19.png)

![alt text](image-20.png)

![alt text](image-21.png)

![alt text](image-22.png)

Cadenas (strings)

* Los objetos de tipo str pueden representarse con ‚Äú ‚Äù o ‚Äò ‚Äô.
* El operador + tiene diferente significado seg√∫n el tipo de dato (overloaded). Con cadenas significa concatenaci√≥n.
* El operador * es el operador de repetici√≥n con cadenas.
* Las cadenas son inmutables.

Entradas (inputs)

* Python tiene la funci√≥n input para recibir datos del usuario del programa.
* Input siempre regresa cadenas, por lo que si queremos utilizar otro tipo, tenemos que hacer type casting.

![alt text](image-23.png)

![alt text](image-24.png)

![alt text](image-25.png)

### Programas ramificados

```sh
>>> 2 == 3
>>> 2 != 3
>>> 2 > 3
>>> 2 < 3
>>> 2 <= 3
>>> 2 >= 3
```

```sh
>>> True and True
>>> False or True
>>> not True
```

![alt text](image-26.png)

![alt text](image-27.png)

```sh
print("Bienvenido al comparador de edades.")
print("Ahora descubriremos juntos quien tiene mas edad entre dos personas.")
print("Para esto necesitare que me brindes informaci√≥n antes (Soy una computadora, no una adivina... por ahora...)")

nombre_persona_1 = input("Necesito el nombre de la primer persona. ¬øComo se llama?: ")
edad_persona_1 = int( input("¬øQue edad tiene?: "))
nombre_persona_2 = input("Necesito el nombre de la segunda persona. ¬øComo se llama?: ")
edad_persona_2 = int( input("¬øQue edad tiene?: "))

print("Despejare la incertidumbre...")

if edad_persona_1 > edad_persona_2:
    print(f"Claro como el agua, {nombre_persona_1} es mayor que {nombre_persona_2}.")
elif edad_persona_1 < edad_persona_2:
    print(f"¬°Elemental Watson!, {nombre_persona_2} es mayor que {nombre_persona_1}.")
else:
    print(f"¬°Basta de contiendas {nombre_persona_1} y {nombre_persona_2}, ambos tienen la misma edad!")

print("Gracias por usar este programa. ¬°Nos vemos la proxima!")
```

### Iteraciones (loops)

* La mayor√≠a de las tareas computacionales no se pueden lograr con ramificaciones.
* Cuando queremos que un programa haga lo mismo varias veces, utilizamos iteraciones.
* Se pueden escribir iteraciones dentro de iteraciones.
* Podemos utilizar break para salir anticipadamente de una iteraci√≥n.
* Tener cuidado de iteraciones infinitas.

![alt text](image-28.png)

comando para ejecutar

```sh
python3 iteraciones.py
```

![alt text](image-29.png)

### Bucles for

Los bucles, en diversos lenguajes de programaci√≥n pueden ser definidos o indefinidos. Los bucles definidos preestablecen las condiciones de la iteraci√≥n por adelantado. Por su parte, los bucles indefinidos establecen la condici√≥n en la que una iteraci√≥n terminar√°. En este √∫ltimo tipo de bucles existe el riesgo de que el bucle se vuelva infinito (cuando la condici√≥n de suspensi√≥n nunca se cumple).

Los bucles definidos se implementan en Python a trav√©s del keyword for. Por su parte, los bucles indefinidos se implementan con el keyword while.

Sin embargo, esta no es la √∫nica forma de implementar bucles definidos. Por ejemplo, Javascript puede implementar un bucle definido mediante el siguiente constructo:

```py
for (i = 0; i <= 10; i++) {
  <expresi√≥n>
}
```

El bucle se puede leer de la siguiente manera:

* Inicializa el bucle en 0
* Continua el bucle mientras i sea menor o igual que 10
* Incrementa i en uno al final de cada iteraci√≥n

Es importante se√±alar que la expresi√≥n i++ es equivalente a lo que en Python escribir√≠amos como i += 1.

Una segunda forma de crear un bucle definido es iterando en una colecci√≥n de objetos. Esta es la forma que Python utiliza:

```py
for <variable> in <iterable>:
    <expresi√≥n>
```

**El bucle for en Python**

En la definici√≥n anterior debemos entender <iterable> como una colecci√≥n de objetos; y la <variable> como el elemento espec√≠fico que se est√° exponiendo mediante el bucle en cada iteraci√≥n.

```py
>>> frutas = ['manzana', 'pera', 'mango']
>>> for fruta in frutas:
        print(fruta)

manzana
pera
mango
```

**Iterables**

En Python, un iterable es un objeto que se puede utilizar en un bucle definido. Si un objeto es iterable significa que se puede pasar como argumento a la funci√≥n iter. El iterable que se pasa como par√°metro a la funci√≥n iter
regresa un iterator.

```py
>>> iter('cadena') # cadena
>>> iter(['a', 'b', 'c']) # lista
>>> iter(('a', 'b', 'c')) # tupla
>>> iter({'a', 'b', 'c'}) # conjunto
>>> iter({'a': 1, 'b': 2, 'c': 3}) # diccionario
```

Todas las llamadas anteriores regresan un objeto de tipo iterator.

¬øQu√© pasa si le pasamos a la funci√≥n iter un objeto que no es iterable? Obtendremos un TypeError que se√±ala que el objeto no es un iterable. Esto es un ejemplo de programaci√≥n defensiva en el que Python verifica el tipo del
objeto antes de proceder al c√≥mputo. ¬°Intentalo en tu consola!

Es importante se√±alar que estos no son los √∫nicos tipos de objetos que pueden ser iterable. Existen gran cantidad de ejemplos en la librer√≠a est√°ndar y, de hecho, casi cualquier objeto se puede convertir en un iterable (pero eso
ya lo veremos cuando hablemos de Python avanzado).

**Iterators**

![alt text](image-30.png)

Ahora que ya sabemos c√≥mo obtener un iterator, ¬øQu√© podemos hacer con √©l? Un iterator es un objeto que regresa sucesivamente los valores asociados con el iterable.

```py
>>> frutas = ['manzana', 'pera', 'mango']
>>> iterador = iter(frutas)
>>> next(iterador)
manzana
>>> next(iterador)
pera
>>> next(iterador)
mango
```

Como puedes ver, el iterator guarda el estado interno de la iteraci√≥n, de tal manera que cada llamada sucesiva a next regresa el siguiente elemento. ¬øQu√© pasa una vez que ya no existan m√°s elementos en el iterable? La llamada
a next arrojar√° un error de tipo StopIteration.

**¬øC√≥mo implementa Python los bucles definidos?**

Ahora ya conocemos todos los elementos necesarios para entender que es lo que sucede en Python cuando ejecutamos un bucle for. Considera nuevamente el siguiente c√≥digo:

```py
>>> frutas = ['manzana', 'pera', 'mango']
>>> for fruta in frutas:
        print(fruta)
```

Este bucle se puede describir con los conceptos que explicamos previamente:

* Python llama internamente la funci√≥n iter para obtener un iterator
* Una vez que tiene un iterator llama repetidamente la funci√≥n next para tener acceso al siguiente elemento en el bucle.
* Detiene el bucle una vez que se arroja el error StopIteration.

**Bucles for con diccionarios**

Para iterar a lo largo de un diccionario tenemos varias opciones:

* Ejecutar el bucle for directamente en el diccionario, lo cual nos permite iterar a lo largo de las llaves del diccionario.
* Ejecutar el bucle for en la llamada keys del diccionario, lo cual nos permite iterar a lo largo de las llaves del diccionario.
* Ejecutar el bucle for en la llamada values del diccionario, lo cual nos permite iterar a lo largo de los valores del diccionario.
* Ejecutar el bucle for en la llamada items del diccionario, lo cual nos permite iterar en una tupla de las llaves y los valores del diccionario.

```py
estudiantes = {
    'mexico': 10,
    'colombia': 15,
    'puerto_rico': 4,
}

for pais in estudiantes:
    ...

for pais in estudiantes.keys():
    ...

for numero_de_estudiantes in estudiantes.values():
    ...

for pais, numero_de_estudiantes in estudiantes.items():
    ...
```

**Modificaci√≥n del comportamiento de un bucle for**

Podemos modificar el comportamiento de un bucle for mediante los keywords
break y continue.

break termina el bucle y permite continuar con el resto del flujo de nuestro
programa.

continue termina la iteraci√≥n en curso y continua con el siguiente ciclo de
iteraci√≥n.

**Conclusiones**

Como pudimos observar, Python implementa los bucles definidos mediante los bucles for. Esta implementaci√≥n nos permite iterar a lo largo de cualquier objeto que sea iterable. Para iterar necesitamos un iterador que nos regresar√°
el siguiente valor en cada iteraci√≥n. Todo esto, Python lo puede hacer por nosotros con el constructo for ... in ....

### Representaci√≥n de flotantes

La mayor√≠a del tiempo los n√∫meros flotantes (tipo float) son una muy buena aproximaci√≥n de los n√∫meros que queremos calcular con nuestras computadoras. Sin embargo, ‚Äúla mayor√≠a del tiempo‚Äù no significa todo el tiempo, y cuando no se comportan de esta manera puede tener consecuencias inesperadas.

Por ejemplo, trata de correr el siguiente c√≥digo:

```py
x = 0.0
for i in range(10):
    x += 0.1

if x == 1.0:
    print(f'x = {x}')
else:
    print(f'x != {x}')
```

Es probable que te hayas sorprendido con el resultado. La mayor√≠a de nosotros esperar√≠amos que imprimiera 1.0 en vez de 0.999999999999. ¬øQu√© es lo que pas√≥?.

Para entender qu√© es lo que pas√≥ tenemos que entender que es lo que pasa en la computadora cuando realizamos c√≥mputos con n√∫meros flotantes. Y para eso necesitamos entender n√∫meros binarios.

Cuando aprendiste a contar, lo que en realidad aprendiste es una t√©cnica combinatoria para manipular los siguientes s√≠mbolos que le llamamos n√∫meros: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.

La forma en la que funciona esta t√©cnica es asignando el n√∫mero 10 a la 0 al n√∫mero de la extrema derecha, 10 a la 1 al siguiente, 10 a la 2 al siguiente y as√≠ sucesivamente. De tal manera que el n√∫mero 525 es simplemente la representaci√≥n de (5 *100) + (2* 10) + (5 * 1).

Esto nos dice que el n√∫mero de n√∫meros que podemos representar depende de cuanto espacio tengamos. Si tenemos un espacio de 3, podemos representar 1,000 n√∫meros (10 elevado a la 3) o la secuencia del 0 al 999. Si tenemos 4, podemos representar 10,000 (10 elevado a la 4) o la secuencia del 0 al 9,999. De manera general podemos decir que con una secuencia de tama√±o n, podemos representar 10 elevado a la n n√∫meros.

Los n√∫meros binarios funcionan de la misma manera (de hecho cualquier n√∫mero en cualquier base, por ejemplo, octales o hexadecimales). La √∫nica diferencia es cu√°ntos s√≠mbolos tenemos para representar. En binario nada m√°s tenemos 0, 1;
en hexadecimal tenemos 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f.

De esta manera podemos decir que el n√∫mero de la extrema derecha es cantidad_de_simbolos**0, cantidad_de_simbolos**1, cantidad_de_simbolos**2, etc. Por lo que en binario, que nada m√°s tenemos 2 s√≠mbolos, decimos 2**0, 2**1, 2**2, etc. Por ejemplo el n√∫mero binario 101 es la representaci√≥n de (1 *4) + (0* 2) + (1 * 1), es decir 5.

Esta representaci√≥n nos permite trabajar con todos los n√∫meros positivos enteros dentro del computador, pero ¬øQu√© hacemos con los negativos y los racionales?.

El caso de los n√∫meros negativos es sencillo: simplemente agregamos un bit adicional que representa el signo y la a√±adimos en la extrema izquierda. Por lo que el n√∫mero 0101 ser√≠a +5 y el n√∫mero 1101 ser√≠a -5.

El caso de los racionales es m√°s complejo. En la mayor√≠a de los lenguajes de programaci√≥n modernos los racionales utilizan una implementaci√≥n llamada punto flotante. ¬øC√≥mo funciona esta representaci√≥n?.

Antes de pasar a binario, vamos a pretender que estamos trabajando con una computadora basada en decimales. Un n√∫mero flotante lo representar√≠amos con un par de enteros: los d√≠gitos significativos y el exponente. Por ejemplo, el n√∫mero 2.345 se representar√≠a como (2345 * 10**-3) o (2345, -3).

El n√∫mero de d√≠gitos significativos determinan la precisi√≥n con la que podemos representar n√∫mero. Por ejemplo si nada m√°s tuvi√©ramos dos d√≠gitos significativos el n√∫mero 2.345 no se podr√≠a representar de manera exacta y tendr√≠amos que convertirlo a una aproximaci√≥n, en este caso 2.3.

Ahora pasemos a la verdadera representaci√≥n interna de la computadora, que es en binario. ¬øC√≥mo representar√≠as el n√∫mero 5/8 o 0.625? Lo primero que tenemos que saber es que 5/8 es en realidad el n√∫mero 5 * 2**-3. Por lo que podr√≠amos decir (101, -11) (recuerda que el n√∫mero 5 es 101 en binario y el 3 es 11).

Regresemos a nuestro problema inicial: ¬øC√≥mo representaremos 1/10 (que escribimos en Python c√≥mo 0.1)? Lo mejor que podemos hacer con cuatro d√≠gitos significativos es (0011, -101) que es equivalente a 3/32 (0.09375). ¬øQu√© tal si tuvi√©ramos cinco d√≠gitos significativos? La mejor representaci√≥n ser√≠a (11001, -1000) que es equivalente a 25/256 (0.09765625). ¬øCu√°ntos d√≠gitos significativos necesitamos entonces? Un n√∫mero infinito. No existe ning√∫n n√∫mero que cumpla con la siguiente ecuaci√≥n: sim * 2**-exp.

En la mayor√≠a de las implementaciones de Python tenemos 53 bits de precisi√≥n para n√∫meros flotantes. As√≠ que los d√≠gitos significativos para representar el n√∫mero 0.1 es igual a:

11001100110011001100110011001100110011001100110011001 que es equivalente al n√∫mero decimal: 0.1000000000000000055511151231257827021181583404541015625

Muy cercano a 1/10 pero no exactamente 1/10. Ahora ya sabemos la raz√≥n de esa respuesta tan extra√±a. Hay muy pocas situaciones en la que 1.0 es aceptable, pero 0.9999999999999999 no. Pero ¬øCu√°l es la moraleja de esta historia?

Hasta ahora hemos verificado igualdad con el operador ==. Sin embargo, cuando estamos trabajando con flotantes es mejor asegurarnos que los n√∫meros sean aproximados en vez de id√©nticos. Por ejemplo x < 1.0 and x > 0.99999.

### Enumeraci√≥n exhaustiva

* Tambi√©n llamado ‚Äúadivina y verifica‚Äù.
* Las computadoras actuales son muy muy r√°pidas.
* Uno de los primeros algoritmos que debes tratar.

### Aproximaci√≥n de soluciones

Los algoritmos dependen del hadware.

* Similar a enumeraci√≥n exhaustiva, pero no necesita una respuesta exacta.
* Podemos aproximar soluciones con un margen de error que llamaremos epsilon.

### B√∫squeda Binaria

![alt text](image-31.png)

* Cuando la respuesta se encuentra en un conjunto ordenado, podemos utilizar b√∫squeda binaria
* Es altamente eficiente, pues corta el espacio de b√∫squeda en dos por cada iteraci√≥n

### Funciones y abstracci√≥n

**Abstracci√≥n**

* No nesecita la forma de como funciona, pero como operarla ejemplo una caluladora.

**Decomposici√≥n**

* Permite dividir el c√≥digo en componentes que colaboran con un fin en com√∫n.
* Se puede pensar como mini programas dentro de un programa mayor

Definici√≥n de funciones

![alt text](image-32.png)

Argumentos de Keyword y valores por defecto

![alt text](image-33.png)

### Scope o Alcance

![alt text](image-35.png)

![alt text](image-34.png)

### Especificaciones del c√≥digo

![alt text](image-36.png)

### Recursividad

**Algor√≠tmica** Una forma de crear soluciones utilizando el principio de ‚Äúdivide y vencer√°s.‚Äù
**Program√°tica** Una t√©cnica program√°tica mediante la cual una funci√≥n se llama a s√≠ misma.

**Factoriales**

![alt text](image-37.png)

### Fibonnacci y la Recursividad

La secuencia de Fibonacci es una funci√≥n matem√°tica que se define recursivamente. En el a√±o 1202, el matem√°tico italiano Leonardo de Pisa, tambi√©n conocido como Fibonacci, encontr√≥ una f√≥rmula para cuantificar el crecimiento que ciertas poblaciones experimentan.

Imagina que una pareja de conejos nace, un macho y una hembra, y luego son liberados. Imagina, tambi√©n, que los conejos se pueden reproducir hasta la edad de un mes y que tienen un periodo de gestaci√≥n tambi√©n de un mes. Por √∫ltimo imagina que estos conejos nunca mueren y que la hembra siempre es capaz de producir una nueva pareja (un macho y una hembra). ¬øCu√°ntos conejos existir√°n al final de seis meses?

Una forma de visualizar este crecimiento es mir√°ndolo de forma tabular:![alt text](image-38.png)

![alt text](image-39.png)

Un punto importante a considerar es que para el mes n > 1, hembras(n) = hembras(n - 1) + hembras(n - 2).

Como podemos ver, tenemos una definici√≥n distinta a la de factorial que vimos anteriormente. En espec√≠fico, tenemos dos casos base (0 y 1) y tenemos dos llamadas recursivas (hembras(n - 1) + hembras(n - 2)).

Podemos crear una soluci√≥n recursiva de manera sencilla:

```py
def fibonacci(n):
    if n == 0 or n == 1:
        return 1

    return fibonacci(n - 1) + fibonacci(n - 2)
```

Aunque la definici√≥n es muy sencilla, es tambi√©n bastante ineficiente. En los siguientes cursos de la serie de pensamiento computacional veremos como calcular exactamente la eficiencia de este algoritmo y c√≥mo optimizarlo. De mientras, plat√≠canos si conoces alguna otra definici√≥n recursiva.

![alt text](image-40.png)

### Funciones como objetos

Una de las caracter√≠sticas m√°s poderosas de Python es que todo es un objeto, incluyendo las funciones. Las funciones en Python son "ciudadanos de primera clase".

Esto, en sentido amplio, significa que en Python las funciones:

* Tienen un tipo
* Se pueden pasar como argumentos de otras funciones
* Se pueden utilizar en expresiones
* Se pueden incluir en varias estructuras de datos (como listas, tuplas,diccionarios, etc.)

**Argumentos de otras funciones**

Hasta ahora hemos visto que las funciones pueden recibir par√°metros para realizar los c√≥mputos que definen. Algunos de los tipos que hemos pasado son tipos simples como cadenas, n√∫meros, listas, etc. Sin embargo, tambi√©n pueden recibir funciones para crear abstracciones m√°s poderosas. Veamos un ejemplo:

```py
def multiplicar_por_dos(n):
    return n * 2

def sumar_dos(n):
    return n + 2

def aplicar_operacion(f, numeros):
    resultados = []
    for numero in numeros:
        resultado = f(numero)
        resultados.append(resultado)
        return resultados

 nums = [1, 2, 3]
 aplicar_operacion(multiplicar_por_dos, nums)
 [2, 4, 6]

 aplicar_operacion(sumar_dos, nums)
[3, 4, 5]
```

**Funciones en expresiones**

Una forma de definir una funci√≥n en una expresi√≥n es utilizando el keyword lambda. lambda tiene la siguiente sintaxis: lambda : .

Otro ejemplo interesante es que las funciones se pueden utilizar en una expresi√≥n directamente. Esto es posible ya que como lo hemos platicado con anterioridad, en Python las variables son simplemente nombres que apuntan a un objeto (en este caso a una funci√≥n). Por ejemplo:

```py
sumar = lambda x, y: x + y

sumar(2, 3)
5
```

**Funciones en estructuras de datos**

Las funciones tambi√©n se pueden incluir en diversas estructuras que las permiten almacenar. Por ejemplo, una lista puede guardar diversas funciones a aplicar o un diccionario las puede almacenar como valores.

```py
def aplicar_operaciones(num):
    operaciones = [abs, float]

    resultado = []
    for operacion in operaciones:
        resultado.append(operacion(num))

    return resultado

 aplicar_operaciones(-2)
[2, -2.0]
```

Como pudimos ver, las funciones son objetos muy vers√°tiles que nos permiten tratarlas de diversas maneras y que nos permiten a√±adir capas adicionales de abstracci√≥n a nuestro programa. Comp√°rtenos c√≥mo te imaginas que estas capacidades de Python te pueden ayudar a escribir mejores programas.

![alt text](image-41.png)

### Tuplas

* Son secuencias inmutables de objetos.
* A diferencia de las cadenas pueden contener cualquier tipo de objeto.
* Puede utilizarse para devolver varios valores en una funci√≥n.

Las tuplas al igual que las listas en Python son secuencias pero las tuplas son secuencias inmutables (eso significa que no se pueden modificar) de objetos.

¬øC√≥mo identificar una tupla en Python? Las tuplas en Pyhton poseen siguiente sintaxis:

```py
tuple_name = ('first_value', 2, 'u_can_add_ints')
```

Mientras que las listas en Python tienen esta sintaxis:

```py
list_name = [1,'2', 3]
```

Como pueden apreciar, para la asignaci√≥n de las tuplas, el contenido debe ir "empaquetado" mediante par√©ntesis "()", mientras que para las listas, se empaquetan en corchetes "[]".
Para declarar una tupla en Python se realiza lo siguiente:

```py
tuple_name = ()
```

El contenido de la tupla pueden ser de tipo int, float y string.
Nota: en caso de que tu tupla s√≥lo contenga un valor, debes agregar una comar ",", por ejemplo:
En caso de contener un int:

```py
tuple_name = (1,) 
```

En caso de contener un float:

```py
tuple_name = (2.0,) 
```

En caso de contener un string:

```py
tuple_name = ('string',) 
```

### Rangos

* Representan una secuencia de enteros.
* range(comienzo, fin, pasos)
* Al igual que las cadenas y las tuplas, los rangos son inmutables.
* Muy eficientes en uso de memoria y normalmente utilizados en for loops
* Representan una secuencia de enteros, y se definen como range(inicio, fin, paso), y al igual que las cadenas y las tuplas, los rangos son inmutables.
* Son muy eficientes en uso de memoria y normalmente son utilizados en for loops.
* Nuevamente, el final no es inclusivo üëÄ.
* Para ver la direcci√≥n en memoria de un objeto, usamos la funci√≥n id(objeto).
* Si lo que queremos es comparar igualdad de objetos en lugar de igualdad de valores, podemos hacer objeto is objeto_2.
* Soluci√≥n al reto: range(1, 100, 2)

```py
my_range = range(1, 10, 1)
print(type(my_range)) #Tipo 

for i in range(2, 10, 2): #Imprime pares
 print(i)
```

### Listas y mutabilidad

* Son secuencias de objetos, pero a diferencia de las tuplas, s√≠ son mutables.
* Cuando modificas una lista, pueden existir efectos secundarios (side effects)
* Es posible iterar con ellas.

* Para modificar una lista podemos:
‚óã Asignar v√≠a √≠ndice (my_lista[0] = 5)
‚óã Utilizar los m√©todos de la lista (append, pop, remove, insert, etc.)

<https://docs.python.org/3/tutorial/datastructures.html#more-on-lists>

Los nuevos que encontr√© adem√°s de los de la clase:

* lista.extend(iterable) #extiende la lista con valores dentro de un iterable como un range()
* lista.insert(i, 'valor') #Agrega un valor en la posici√≥n i y recorre todos los dem√°s. No borra nada.
* lista.pop(i) #Elimina valor en la posici√≥n i de la lista.
* lista.remove('valor') #Elimina el primer elemento con ese valor.
* lista.clear() #Borra elementos en la lista.
* lista.index('valor') #Retorna posici√≥n del primer elemento con el valor.
* lista.index('valor', start, end) #Retorna posici√≥n del elemento con el valor dentro de los elementos desde posici√≥n start hasta posici√≥n end)
* lista.count('valor') #Cuenta cu√°ntas veces esta ese valor en la lista.
* lista.sort() #Ordena los elementos de mayor a menor.
* lista.sort(reverse = True) #Ordena los elementos de menor a mayor.
* lista.reverse() #Invierte los elementos
* lista.copy() #Genera una copia de la lista. Tambi√©n √∫til para clonar listas.

**Clonaci√≥n**

* Casi siempre es mejor clonar una lista en vez de mutarla
* Para clonar una lista podemos utilizar rebanadas (slices) o la funci√≥n list

```sh
    a = list()
    a = a[::]
```

**List comprehension**

* Es una forma concisa de aplicar operaciones a los valores de una secuencia.
* Tambi√©n se pueden aplicar condiciones para filtrar.

![alt text](image-42.png)

![alt text](image-43.png)

### Diccionarios

* Son como listas, pero en lugar de usar √≠ndices utilizan llaves.
* No tienen orden interno.
* Los diccionarios son mutables.
* Pueden iterarse.

<https://www.datacamp.com/community/tutorials/python-dictionary-comprehension>

![alt text](image-44.png)

### Pruebas de caja negra

* Se basan en la especificaci√≥n de la funci√≥n o el programa.
* Prueba inputs y valida outputs.
* Unit testing o integration testing.

<https://platzi.com/blog/que-es-y-como-funciona-tdd/>

### Pruebas de caja de cristal

* Se basan en el flujo del programa.
* Prueba todos los caminos posibles de una funci√≥n. Ramificaciones, bucles for y while, recursi√≥n.
* Regression testing o mocks.

### Debugging

**Reglas generales**

* No te molestes con el debugger. Aprende a utilizar el print statement.
* Estudia los datos disponibles.
* Utiliza los datos para crear hip√≥tesis y experimentos. M√©todo cient√≠fico
* Ten una mente abierta. Si entendieras el programa, probablemente no habr√≠an bugs.
* Lleva un registro de lo que has tratado, preferentemente en la forma de tests.

**Dise√±o de experimentos**

* Debugear es un proceso de b√∫squeda. Cada prueba debe acotar el espacio de b√∫squeda.
* B√∫squeda binaria con print statements.

**Errores comunes**

* Encuentra a los sospechosos comunes.
* En lugar de preguntarte por qu√© un programa no funciona, preg√∫ntate por qu√© est√° funcionando de esta manera.
* Es posible que el bug no se encuentre donde crees que est√°.
* Expl√≠cale el problema a otra persona. De preferencia que no tenga contexto.
* Lleva un registro de lo que has tratado, preferentemente en la forma de tests.
* Vete a dormir.
